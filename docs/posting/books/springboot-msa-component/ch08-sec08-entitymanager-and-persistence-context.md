### 엔티티의 생명주기

영속성 컨텍스트 (persistence context)는 영속하려는 엔티티 객체의 집합을 의미하며, 엔티티 객체의 생명주기를 관리하는 컨텍스트 객체이다.

![entity-lifecycle.png](images/entity-lifecycle.png)

- 생성 상태 (NEW, TRANSIENT) 
	- 영속성 컨텍스트에 한번도 속하지 않는 new 로 생성된 객체이다.

!!! warn

    근데 여기서 한가지 주의할 점이 있다. JPA 가 내부적으로 NEW 상태임을 판단하는 기준은 ID 의 여부이다. 
    @Id 필드가 `Long`, `Integer` 같은 객체타입인 경우 `null`. `int`, `long` 같은 원시 타입인 경
    우 기본값(0, 0L) 이라면 NEW 상태의 엔티티 이지만 그렇지 않은 경우 준영속 상태로 판단해 save 메서드 호
    출시 em.persist 가 아니라 em.merge 가 호출된다. 이때 save 를 호출하였음에도 insert 쿼리가 아니라
    변경 감지기능이 동작하여 select 쿼리와 update 쿼리가 발생 할 수 있다.

- 영속 상태 (MANAGED)
	- 객체가 영속성 컨텍스트에 의해 관리되는 상태이다.
	- 영속성 컨텍스트에 의해 관리된다는 것은 영속성 컨텍스의 기능인 1차 캐시, 더티 체킹 등의 기능이 동작하는 상태라는 의미이다.
- 준영속 상태 (DETACHED)
	- Managed 상태의 객체는 `em.detach()` 를 통해 영속성 컨텍스트의 관리에서 빠져나갈 수 있다.
	- `em.merge()` 를 통해 다시 MANAGED 상태가 될 수 있다.
- 삭제 상태 (REMOVED)
	- `em.remove()` 에 의해 삭제 된 상태이다.
	- `em.flush()` 가 호출되면 삭제 쿼리가 발생한다.

### 영속성 컨텍스트의 특징

- 1차 캐시
	- 같은 트랜잭션에서 영속성 컨텍스트에 저장된 엔티티에 대해서 ***ID 로 조회 요청***을 하면 영속성 컨텍스트 메모리 내에서 객체를 조회해 준다.
- 동일성 보장
	- 마치 자바 컬렉션을 활용하는 것 처럼 같은 엔티티에 대해서는 identity 연산의 참이 보장된다.
- 변경 감지 (더티 체킹)
	- 영속성 컨텍스트에서 조회한 엔티티를 수정하고 다시 이를 persist 한다거나 merge 할 필요가 없다.
	- 트랜잭션이 마무리 되는 시점에 영속성 컨텍스트는 트랜잭션 시작시점의 스냅샷과 비교하여 변경을 감지해 자동으로 update 쿼리를 발생시킨다.
- 지연 로딩
	- 연관 관계에 있는 엔티티 객체들은 지연 로딩 설정에 따라 참조될 때 로딩할 수 있다.
- 쓰기 지연 (을 지원하는 SQL 저장소)
	- CUD 쿼리를 매번 데이터 베이스에 반영하지 않고 `em.flush()` 가 호출 될 때 한 번에 반영한다.

!!! warn

    @GenratedValue 의 전략이 `GenerationType.IDENTITY` 즉 auto-increment 로 설정된 경우는 
    save 호출시 바로 insert 쿼리가 발생한다. 영속성 컨텍스트에의해 관리 되기 위해서는 id 값이 필요하기 때문이다.
    
